---
title:  Kotlin流程控制
date: 2021-06-02 09:13:29
permalink: /pages/487be4/
categories:
  - Kotlin笔记
  - Kotlin语言基础
tags:
  - kotlin
author:
  name: iqqcode
  link: https://github.com/IQQcode
---
【参考文档】

- [🎈Kotlin 循环控制](https://www.runoob.com/kotlin/kotlin-loop-control.html)

----------------

## for循环

Java `for-each`循环

```java
for (item : list)
```

> Kotlin也能使用类似形式的循环，区别在于把冒号 `:` 换成了关键字 `in`，具体语句形如 `for (item in list)`

下面是Kotlin对数组进行循环处理的代码例子：

```kotlin
fun main(args: Array<String>) {
    val poemArray: Array<String> = arrayOf("朝辞白帝彩云间", "千里江陵一日还", "两岸猿声啼不住", "轻舟已过万重山")

    for (item in poemArray) {
        print("$item,\n")
    }

    println("========================\n")
    
    for (i in poemArray.indices) {
        if (i % 2 == 0)  println("${poemArray[i]}，") 
        else println("${poemArray[i]}。")
    }
}
```

Kotlin `in` 关键字也可以替代`for-i`循环

```kotlin
 for (i in poemArray.indices) { }
```

然而取消 `for (初始; 条件; 增减)` 这个规则是有代价的，因为实际开发中往往存在非同一般的需求，比如以下几种情况，Kotlin的 `for (i in array.indices)` 语句就无法很好地处理：

1. 如何设定条件判断的起始值和终止值？
2. 每次循环之后的递增值不是1的时候要怎么办？
3. 循环方向不是递增而是递减，又如何是好？
4. 与条件判断有关的变量不止一个，咋整？
5. 循环过程中的变量，在循环结束后还能不能使用？

针对以上情况，其实Kotlin也给出了几个解决办法，代价是多了诸如 **until、step、downTo** 这样的关键字，具体用法见下列代码：

```kotlin
// 左闭右开区间 [11, 66)，合法值包括11，但不包括66
for (i in 11 until 66) { ... }

// 每次默认递增1，这里改为每次递增4
for (i in 23..89 step 4) { ... }

// for循环默认递增，这里使用downTo表示递减
for (i in 50 downTo 7) { ... }
```

> 可是这些解决办法并不完美，因为业务需求是千变万化的，并非限定在几种固定模式。同时，以上规则容易使人混淆，一旦没搞清until和downTo的开闭区间，在判断边界值时会产生问题。所以更灵活的解决方案是：起止数值、条件判断、循环方向与递增值都应当在代码中明确指定，`for (初始; 条件; 增减)` 这个规则固然废除了，但开发者依旧能够使用while语句实现相关功能

### 小结

正常循环：

```kotlin
for (i in 1..4) print(i)  // 打印结果为: "1234"
```

如果你需要按反序遍历整数可以使用标准库中的 downTo() 函数:

```kotlin
for (i in 4 downTo 1) print(i)  // 打印结果为: "4321"
```

也支持指定步长：

```kotlin
for (i in 1..4 step 2) print(i) // 打印结果为: "13"

for (i in 4 downTo 1 step 2) print(i) // 打印结果为: "42"
```

如果循环中不要最后一个范围区间的值可以使用 until 函数:

```kotlin
for (i in 1 until 10) { // i in [1, 10), 不包含 10
     println(i)
}
```

<br>

## While循环被保留

**while循环**

```kotlin
val poemArray: Array<String> = arrayOf("朝辞白帝彩云间", "千里江陵一日还", "两岸猿声啼不住", "轻舟已过万重山")
    val poem: String = ""
    var i: Int = 0
    while (i < poemArray.size) {
        if (i % 2 == 0) {
            println("${poemArray[i]}，")
        } else {
            println("${poemArray[i]}。")
        }
        i++
    }
    println("${poem}该诗歌一共有${i}句。")
```

**do...while循环：同Java**

-----------------------------------

## 实例测试

前面的循环处理其实都还中规中矩，只有内忧没有外患，但要是数组里的诗句本身就不完善，比如有空指针、有空串、有空格串、有多余串等等，此时就得进行诗句的合法性判断，如此方可输出正常的诗歌文字。合法性判断主要由两块代码组成：

1. 如果发现有空指针、有空串、有空格串，则忽略此行，即使用关键字continue继续下个循环；
2. 如果合法诗句达到四句，则不管是否遍历完成，直接拼好绝句并结束循环，即使用关键字break跳出循环；加入了合法性判断的代码见下，主要演示了`continue` 和 `break`：

```kotlin
fun main(args: Array<String>) {
    val poemArray: Array<String?> = arrayOf("朝辞白帝彩云间", null, "千里江陵一日还", "", "两岸猿声啼不住", "   ", "轻舟已过万重山", "送孟浩然之广陵")
    var pos: Int = -1
    var count: Int = 0
    while (pos <= poemArray.size) {
        pos++
        if (poemArray[pos].isNullOrBlank())
            continue
        if (count % 2 == 0) {
            println("${poemArray[pos]}，")
        } else {
            println("${poemArray[pos]}。")
        }
        count++
        if (count == 4)
            break
    }
}
```



## goto语句，标签处返回

外层循环加个@标记

```kotlin
fun main(args: Array<String>) {
    val poemArray: Array<String?> = arrayOf("朝辞白帝彩云间", null, "千里江陵一日还", "", "两岸猿声啼不住", "   ", "轻舟已过万重山", "送孟浩然之广陵")
    var i: Int = 0
    var is_found = false
    outside@ while (i < poemArray.size) {
        var j: Int = 0
        val item = poemArray[i];
        if (item != null) {
            while (j < item.length) {
                if (item[j] == '一') {
                    is_found = true
                    break@outside
                }
                j++
            }
        }
        i++
    }
    println(if (is_found) "我找到'一'字啦" else "没有找到'一'字呀")
}
```

### 标签处返回

Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：

```kotlin
fun foo() {
    ints.forEach {
        if (it == 0) return
        print(it)
    }
}
```

这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。

```kotlin
fun foo() {
    ints.forEach lit@ {
        if (it == 0) return@lit
        print(it)
    }
}
```

现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。

```kotlin
fun foo() {
    ints.forEach {
        if (it == 0) return@forEach
        print(it)
    }
}
```

或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回

```kotlin
fun foo() {
    ints.forEach(fun(value: Int) {
        if (value == 0) return
        print(value)
    })
}
```

当要返一个回值的时候，解析器优先选用标签限制的 return，即

```kotlin
return@a 1
```

意为"从标签 @a 返回 1"，而不是"返回一个标签标注的表达式 (@a 1)"。

<br>

----------------------

<br>

## When

kotlin的when其实就是对java的switch的一个升级

switch分支语句

```java
String ans = "B";
switch (ans) {
    case "A":
        // TODO
        break;
    case "B":
        // TODO
        break; 
    default:
        break;
}
```

when分支语句

```kotlin
String ans = "A";
when (ans) {
    "A" -> {
        // TODO
    }
    "B" -> {
        // TODO
    }
    else -> {
        // TODO
    }
}
```

不写break的话会接着执行下一个case进行比较么？不是的，这个when的结果是只会执行”比较B"是否相等并且输出“B"的花括号里的内容后跳出当前when。

如何像java一样不写break的话会执行多个呢？

```kotlin
var num = 6;
when (num) {
    in 1..20 -> {
        // TODO
    }
}

var res = "null"
when (res) {
    is String -> {
        // TODO
    }
}
```

> - is 就是 Java的 `instanceof`
> -  as 就是用来强制类型转换的



--------------

【原文转载】：

[1] aqi00. Kotlin入门(7)循环语句的操作[EB/OL]. https://www.cnblogs.com/aqi00/p/7192967.html

[2] 苗小帅. Kotlin之流程控制[EB/OL]. https://www.jianshu.com/p/01eaac5f8767